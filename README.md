[![npm version](https://badge.fury.io/js/rest-core.svg)](http://badge.fury.io/js/rest-core)

[![NPM](https://nodei.co/npm/rest-core.png?downloads=true&downloadRank=true&stars=true)](https://nodei.co/npm/rest-core/)

# rest-core
Rest Core is an evolution of ngx-resource lib which provides freedom for the developers. Each developer can implement his own request handlers.
In fact, `rest-core` is an abstract common library which uses `RestHandler` to make an requests, so it's even possible to use the lib on node.js server side with typescript. Just need to implement `RestHandler` for it.

All my examples will be based on angalar 4.4.4+

### Known `RestHandlers`
* `rest-ngx`. Based on `HttpClient` from Angular. Includes `RestModule.forRoot`. [GitHub](https://github.com/troyanskiy/rest-ngx)
* `rest-cordova-advanced-http`. Based on [Cordova Plugin Advanced HTTP](`https://github.com/silkimen/cordova-plugin-advanced-http`). [GitHub](https://github.com/troyanskiy/rest-cordova-advanced-http)
* `rest-fetch`. Besed on [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). Not yet created.


## Creation of rest class

```typescript
@Injectable()
@RestParams({
  // IRestParams
  pathPrefix: '/auth'
})
export class MyAuthRest extends Rest {

  @RestAction({
    // IRestAction
    method: RestRequestMethod.Post
    path: '/login'
  })
  login: IRestMethod<{login: string, password: string}, IReturnData>; // will make an post request to /auth/login

  @RestAction({
    // IRestAction
    //method: RestRequestMethod.Get is by default
    path: '/logout'
  })
  logout: IRestMethod<void, void>;
  
  constructor(restHandler: RestHandler) {
    super(restHandler);
  }
  
}

@Injectable()
@RestParams({
  // IRestParams
  pathPrefix: '/user'
})
export class UserRest extends Rest {
  
  @RestAction({
    path: '/{!id}'
  })
  getUser: IRestMethod<{id: string}, IUser>; // will call /user/id
  
  @RestAction({
    method: RestRequestMethod.Post
  })
  createUser: IRestMethodStrict<IUser, IUserQuery, IUserPathParams, IUser>;
  
  constructor(restHandler: RestHandler) {
    super(restHandler);
  }
  
}

// Using created rest
@Injectable
export class MyService {
  
  private user: IUser = null;

  constructor(private myRest: MyAuthRest, private userRest: UserRest) {}
  
  doLogin(login: string, password: string): Promise<any> {
    return this.login({login, password});
  }
  
  doLogout(): Promise<any> {
    return this.logout();
  }
  
  async loginAndLoadUser(login: string, password: string, userId: string): Promise<any> {
    await this.doLogin(login, password);
    this.user = await this.userRest.getUser({id: userId});
  }
  
}

```

Final url is generated by concatination of `$getUrl`, `$getPathPrefix` and `$getPath` methods of `Rest` base class.

### [IRestParams](https://github.com/troyanskiy/rest-core/blob/master/src/Declarations.ts#L2-L23) 

Is used by `RestParams` decorator for class decoration

List of params:
* `url?: string;` - url of the api server; *default `''`*
* `pathPrefix?: string;` - path prefix of the api; *default `''`*
* `path?: string;` - path of the api; *default `''`*
* `headers?: any;` - headers; *default `{}`*
* `body?: any;` - default body; *default `null`*
* `params?: any;` - default url params; *default `null`*
* `query?: any;` - defualt query params; *default `null`*
* `rootNode?: string;` - key to assign all body; *default `null`*
* `removeTrailingSlash?: boolean;` - *default `true`*
* `addTimestamp?: boolean | string;` - *default `false`*
* `withCredentials?: boolean;` - *default `false`*
* `lean?: boolean;` - do no add `$` properties on result. Used only with `toPromise: false` *default `false`*
* `mutateBody?: boolean;` - if need to mutate provided body with response body. *default `false`*
* `asPromise?: boolean;` - if method should return promise or object, which will be fullfilled after receiving response. *default `true`*
* `requestBodyType?: RestRequestBodyType;` - request body type. *default: will be detected automatically*.
Check for possible body types in the sources of [RestRequestBodyType](https://github.com/troyanskiy/rest-core/blob/master/src/Declarations.ts#L114-L122). Type detection algorithm [check here](https://github.com/troyanskiy/rest-core/blob/master/src/RestHelper.ts#L12-L34).
* `responseBodyType?: RestResponseBodyType;` - response body type. *default: `RestResponseBodyType.JSON`* Possible body type can be checked here [RestResponseBodyType](https://github.com/troyanskiy/rest-core/blob/master/src/Declarations.ts#L124-L129).

### [IRestAction](https://github.com/troyanskiy/rest-core/blob/master/src/Declarations.ts#L2-L31) 

Is used by `RestAction` decorator for methods.

List of params (is all above) plus following:
* `method?: RestRequestMethod;` - method of request. *Default `RestRequestMethod.Get`*. All possible methods listed in [RestRequestMethod](https://github.com/troyanskiy/rest-core/blob/master/src/Declarations.ts#L131-L139)
* `expectJsonArray?: boolean;` - if expected to receive an array. The field is used only with `toPromise: false`. *Default `false`*.
* `resultFactory?: IRestResultFactory;` - custom method to create result object. *Default: `returns {}`*
* `map?: IRestResponseMap;` - custom data mapping method. *Default: `returns without any changes`*
* `filter?: IRestResponseFilter;` - custom data filtering method. *Default: `returns true`*

### [RestGlobalConfig](https://github.com/troyanskiy/rest-core/blob/master/src/RestGlobalConfig.ts)
Mainly used to set defaults


## Models
What is that. It's an object which has build in methods to save, update, delete an model.
Here is an example of `User` model.

```typescript

export interface IPaginationQuery {
  page?: number;
  perPage?: number;
}

export interface IGroupQuery extends IPaginationQuery {
  title?: string;
}

export interface IUserQuery extends IPaginationQuery {
  firstName?: string;
  lastName?: string;
  groupId?: number;
}

export interface IUser {
  id: number;
  userName: string;
  firstName: string;
  lastName: string;
  groupId: string;
}

export class GroupRest extends RestCRUD<IGroupQuery, Group, Group> {
  
  constructor(restHandler: RestHandler) {}
  
  $resultFactory(data: any, options: IRestActionInner = {}): any {
    return new Group(data);
  }
  
}

export class Group extends RestModel {
  
  readonly $rest = GroupRest;

  id: number;
  title: string;
  
  constructor(data?: IGroup) {
    if (data) {
      this.$setData(data);
    }
  }
  
  $setData(data: IGroup) {
    this.id = data.id;
    this.title = data.title;
  }
  
}

export class UserRest extends RestCRUD<IUserQuery, User, User> {
  
  constructor(restHandler: RestHandler) {}
  
  $resultFactory(data: any, options: IRestActionInner = {}): any {
    return new User(data);
  }
  
}

export class User extends RestModel implements IUser {

  readonly $rest = UserRest;

  id: number;
  userName: string;
  firstName: string;
  lastName: string;
  groupId: string;
  
  fullName: string; // generated from first name and last name
  
  constructor(data?: IUser) {
    if (data) {
      this.$setData(data);
    }
  }
  
  $setData(data: IUser) {
    Object.assign(data);
    this.fullName = `${this.firstName} ${this.lastName}`;
  }
  
  toJSON() {
    // here i'm using lodash lib pick method.
    return _.pick(this, ['id', 'firstName', 'lastName', 'groupId']);
  }

}


// example of using the staff
async someMethodToCreateGroupAndUser() {

  // Creation a group
  const group = new Group();
  group.title = 'My group';
  
  // Saving the group
  await group.$save();
  
  // Creating an user
  const user = new User({
    userName: 'troyanskiy',
    firstName: 'firstName',
    lastName: 'lastName',
    groupId: group.id
  });
  
  // Saving the user
  await user.$save();
  
}

```


## Developing Rest Handler

Use [`RestHandler`](https://github.com/troyanskiy/rest-core/blob/master/src/RestHandler.ts) abstract class as parent to create your Handler. I think it's clear what should it do by checking sources of the class.
